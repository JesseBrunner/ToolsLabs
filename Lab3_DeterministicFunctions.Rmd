---
title: 'Getting a feel for deterministic functions: EMD chapter 3'
author: "Jesse Brunner (with material from Jacqui Frair & John Stella)"
date: "January 26, 2015"
output: html_document
---


Our goals in this lab are to: 

1. get a feel for a suite of important deterministic functions, seeing how their parameters changer their shapes and behavior
2. create reference figures that you can refer to when using these functions
3. learn to create your own function representing the model that _you_ want

Creating functions: the negative exponential
--------------------------------------------

There are a number of "built in" deterministic functions in R, but it will be very useful if we can create our own. It turns out that they are very easy to make. To illustrate how we do this, let’s make a function that computes values of negative exponential:
$$
  \begin{aligned}
  y & = a \times \exp(-bx)
  \end{aligned}
$$

The basic syntax of any function is:
```{r NegExp_1, eval=FALSE}
FunctionName <- function() {
	
}
```

The stuff inside the parentheses is list of "arguments" that the function takes (or requires). The negative exponential function requires one or more $x$-values, as well as two parameters, $a$ and $b$. 
```{r NegExp_2, eval=FALSE}
NegExp <- function(x, a, b) {
	
}
```

The stuff inside the curly brackets is the heart of the function, the part that does something. In our case, it does the math:
```{r NegExp_3}
NegExp <- function(x, a, b) {
	a*exp(-b*x)
}
```
It is worth noting that by default the last value that is calculated in a function is "returned". In this case, it means that the value of `a*exp(-b*x)` is returned. We'll return to this in a moment. 

Let's try this function and see how it works. First, let's create a sequence of $x$-values, then we will plug them into our `NegExp()` function. 
```{r NegExp_call}
x <- seq(from = 0, to = 10, length = 50)
y <- NegExp(x, a = 1, b = 1)
y
```

Right. So we feed our function a vector of x-values and it spits out a vector of y-values, which, at first glance, seem to be about right. Let’s plot it and see.

```{r NegExp_plot, fig.width = 5, fig.height = 4}
library(ggplot2) #don't forget to load the package
qplot(x,y, geom = "line")
```

It works! Whoo hoo! Your first function! 
	
	Now, we can make two important changes. First, we can provide default, but override-able values to the arguments of a function. This is good practice because a) it lets you specify _just_ the thing(s) you want to change and b) there are built in "reasonable" values. It’s good to get in the habit.

```{r NegExp_4, fig.width = 5, fig.height = 4}
NegExp <- function(x, a = 1, b = 1) {a*exp(-b*x)}
y.1 <- NegExp(x) # using default values
qplot(x, y.1, geom = "line")
y.2 <- NegExp(x, b=1/3) # using default value of a, but changing b
qplot(x, y.2, geom = "line")
```

The other thing to note, as I mentioned before, is that our function is returning a vector of values. We'll see later that a function can do a whole bunch of things, but it can only return one object (a vector, a matrix, a list...). By default a function returns the result of the last calculation, but with more complicated functions it is good practice to specify the thing you want returned by using `return(ThingToReturn)`. So in our case we would write:
```{r NegExp_5}
NegExp <- function(x, a = 1, b = 1) {
y <- a*exp(-b*x)
return(y)
}
```
And there you go; you're first fully developed function in R!
	
------------------

**Side Note:** One thing to note is that we have a `y` inside the function, which is returned, and a `y` outside the function, which is was we call the output from our function. These are different things. The `y` inside the function _does not exist_ outside of the function. We could call it anything and so long as it was consistent inside the function, it would work just fine. Similarly, we could name the resulting output of our function anything we want (within the naming rules of R) and we'll be fine. And just to be complete (if silly), we could _give_ our function a variable called `y` (e.g., `NegExp(x, a = y, b = 1)`) and it wouldn't matter. The function would know what we meant (i.e., it would simply take the value in `y` and assign it to an internal variable named `a` and then use that... it wouldn't "know" anything about what those values were called outside of itself). This might all seem a bit confusing, but it is important to note how _useful_ this is.  It means that you don't need to know what the inside of a function looks like to use! For instance, you've used `summary()` a whole bunch of times, right? Do you have to worry that you don't give it a variable name that is uses for its own purposes internally? No! That makes our life much easier.   

------------------

### A few things to remember about functions:

* Functions can have 0, 1, 2, or many inputs in the parentheses. These may be any type of object or data such as character strings, TRUE/FALSE, vectors of numbers, matrices, data frames, lists.  

* Functions can only return __1__ things, although it can be complex (e.g., an object, data frame, matrix). It is good practice to make the last statment of your function be a `return()`.  

* While a function can plot or print things out, the returned object/data is the only thing that can be assigned to a variable (i.e., the only thing you can work with afterwards).  

* You may create new variables within a function (e.g., `y` in the `NegExp()` function above) but that variable exists only within the function. This is a _good_ thing. Imagine if you called a function that had an interval variable called `y` that _overwrote_ the variable `y` you had in your workspace! It would be dangerous working with unknown functions! This way you do not need to pay attention to the internal workings of any given function.  

* It is possible to have a function create or change a "global" variable by using the double-arrow assignment symbol `<<-`  instead of the normal  `<-` . This can be powerful, but Be Very Careful!  


### Two bits of advice: 

1.  While a single function can do lots of things---reorganize your data, calculate, some statistics, plot the results, and then send you back a table of something important---it is generally better to have a function do one thing and one thing only. This gives you the flexiblity to re-use those single-function functions in new ways, or string together functions in new ways that maybe you never thought of before. Thing of functions as Legos, that you can combine in useful structures. You will start to get the hang of this, and how to make your functions more general, but for now, just keep it simple and understandable. And make a file of useful functions that you can crib or steal from later.  

2.  There are a number of methods for trouble-shooting functions. The simplest is to just walk through what a function is doing, step-by-step. In fact you would do well to build up a function slowly, making sure you know how it's working along the way. The tendancy is to write a function from start to finish, try it, and then say "It doesn't work!" Then you have trouble. Instead, write a function that does the first thing  you need it do. Does that work? If so, move on to the next thing. You can use the `print()` or `paste()` functions to see what different variables look like in the function, too. 


Plotting curves with stat_function()
------------------------------------

We ended the last section by generating a vector of x-values, then using our function to calculate corresponding y-values, and then plotting them against one another. Instead we can do this in one step by using the built-in `stat_function()` of the ggplot2 package. It is designed for just this purpose.
We can plot any function we like, such as this one:
```{r madeup_stat_fun, fig.width = 5, fig.height = 4}
qplot(x=c(0,5), stat="function", fun=function(x)  10*(1 -exp(-2*x) -1/30*x^2), geom="line")
```

Or use named functions, like our `NegExp()` function (or anything else built into R).																																																																																																																																																																																																																																																																																																																																																												
```{r NegExp_stat_fun, fig.width = 5, fig.height = 4}
qplot(x=c(0,10), stat="function", fun=NegExp, geom="line")
```

Notice that we did not say `fun=NegExp(x, a, b, c)` or something similar. ggplot2 just wants to know the name of the function. If we want to specify arguments to the function (e.g., change the value of `a`) we can use `args=list()` such as:
```{r NegExp_stat_fun_args, fig.width = 5, fig.height = 4}
qplot(x=c(0,10), stat="function", fun=NegExp, args=list(a=3), geom="line")
```

If we want to plot more than one curve on the same axes, we need to use the `ggplot()` version of things, rather than `qplot()`. We are assigning color to different character strings in the `aes()` part, so that the function knows to create entries in a legend for each with the appropriate colors. We then have to specify values of the colors and the breaks within the `scale_colour_manual()` function. Note that the names are assigned alphabetical, so even though "`a=0.5, b=1`" is the last entry, it gets the first color listed (here, red).
```{r guide_NegExp}
NE <- ggplot(data.frame(x=c(0,10)), aes(x)) +  
	stat_function(fun=NegExp, geom="line", args=list(a=1, b = 0.5), aes(colour="a=1, b=0.5")) +  
	stat_function(fun=NegExp, geom="line", args=list(a=1, b = 1),   aes(colour="a=1, b=1")) +   
	stat_function(fun=NegExp, geom="line", args=list(a=1, b = 2),   aes(colour="a=1, b=2")) +  
	stat_function(fun=NegExp, geom="line", args=list(a=1/2, b = 1), aes(colour="a=0.5, b=1")) +  
	scale_colour_manual("Parameters", 
		values=c("red", "lightblue", "blue", "darkblue"), 
		breaks=c("a=1, b=0.5", "a=1, b=1",  "a=1, b=2", "a=0.5, b=1")) +   
	labs(title = "Negative Exponential") + theme_bw()
NE
```

There is a lot embeded in this code, so let me go through it again. First, we're adding several "layers" of `stat_function`, each with different lists of arguments. Then we are assigning a color to a given label (`aes` stands for aesthetics). Finally we specify what colors we want for each label using the `scale_colour_manual()` function. The names of the breaks need to be the same as the names you used above for each label.  (Note, you could simply specify the actualy color you wanted each line to be using `stat_function(..., colour="red")`, but then we wouldn't get the legend with the specific parameters.)

I think that this sort of figure is a handy reference. You may want to turn this into a pdf and keep it handy or print it out. It's relatively easy to do:
```{r NegExp_pdf, eval=FALSE}
ggsave(NE, file="NegativeExponential.pdf", width = 8, height = 6) # width in inches, by default
```

More functions to explore
-------------------------

You should try to at least understand the behavior of, if not create a similar reference pdf of the following deterministic functions. See where they saturate, where the half-maximum shows up, where they wiggle, etc. The approach is the same. Try to code them yourself. If you have trouble with the math, see below.

**Hyperbolic**  
$$
\begin{aligned}
y & = \frac{a}{b+x} 
\end{aligned}
$$

**Michaelis-Menton**
$$
\begin{aligned}
y & = \frac{ax}{b+x} 
\end{aligned}
$$

**Holling Type III**
$$
\begin{aligned}
y & = \frac{ax^2}{b^2+x^2} 
\end{aligned}
$$

**Holling Type IV**
$$
\begin{aligned}
y & = \frac{ax^2}{b+cx+x^2} 
\end{aligned}
$$

**Monomolecular**
$$
\begin{aligned}
y & = a(1-exp(-bx)) 
\end{aligned}
$$

**Ricker**
$$
\begin{aligned}
y & = ax \times exp(-bx)
\end{aligned}
$$

**Logistic**
$$
\begin{aligned}
y & = \frac{exp(a+bx)}{1+exp(a+bx)}
\end{aligned}
$$


These are for your own benefit, so do them, but there is no need to send me anything unless you have questions or produce something really cool.




ifelse() for Piece-wise Functions 
--------------------------------

The `ifelse()` command in R is useful for constructing piece-wise functions.  Its basic syntax is `ifelse(condition, value_if_true, value_if_false)`, where `condition` is a logical vector (e.g., `x > 0`), `value_if_true` is a vector of alternatives to use if condition is `TRUE`, and `value_if_false` is a vector of alternatives to use if condition is `FALSE`.  If you specify just one value, it will be expanded (recycled in R jargon) to be the right length.  A simple example:
```{r ifelse_example}
x <- c(-25, -16, -9, -4, -1, 0, 1, 4, 9, 16, 25)
ifelse(x < 0, 0, sqrt(x))
```

These commands produce a warning message, but it’s OK to ignore it since you know you’ve taken care of the problem.  (If you said `sqrt(ifelse(x < 0, 0, x))` instead you wouldn’t get a warning. Why not? Do you think this would be a better way to formulate)

Here are some examples of using `ifelse()` to generate 

1. a simple threshold   
2. a Holling type I or “hockey stick”   
3. a more complicated piece-wise model that grows exponentially and then decreases linearly   
4. a double-threshold model   

```{r ifelse_plots}

ggplot(data.frame(x=c(0,5)), aes(x)) + 
stat_function(fun=function(x) ifelse(x < 2, 1/2, 2), geom="line", 
							aes(colour="ifelse(x < 2, 1/2, 2)")) +   
stat_function(fun=function(x) ifelse(x < 2, 2 * x, 4), geom="line", 
							aes(colour="ifelse(x < 2, 2 * x, 4)")) +   
stat_function(fun=function(x) ifelse(x < 2, exp(x), 7*exp(-(x-2)/4)), geom="line", 
							aes(colour="ifelse(x < 2, exp(x), 7*exp(-(x-2)/4))")) +   
stat_function(fun=function(x) ifelse(x < 2, 1, ifelse(x < 4, 3, 5)), geom="line", 
							aes(colour="ifelse(x < 2, 1, ifelse(x < 4, 3, 5))")) +   
scale_colour_manual("Piecewise model", 
							values=c("violet", "blue","darkblue","lightblue"), 
							breaks=c("ifelse(x < 2, 1/2, 2)", 
											 "ifelse(x < 2, 2 * x, 4)", 
											 "ifelse(x < 2, exp(x), 7*exp(-(x-2)/4))", 
											 "ifelse(x < 2, 1, ifelse(x < 4, 3, 5))")) + 
theme_bw() +   
theme(legend.position=c(0,1), legend.justification=c(0,1), 
			legend.background=element_blank())

# Notice that last call to theme(). 
# I'm specifying the position and justification to move
# the legend position to the upper left of the graph 
# so that it doesn't squish the graph itself. 
# The part about the background is to prevent the  
# legend's white background from covering the lines.
# element_blank() is way to "delete" an element
```

The double-threshold example (nested `ifelse()` commands) probably needs more explanation.   In words, this command would read “if x is less than 2, set y to 1; otherwise (where x $\ge$ 2), if x is less than 4 (i.e., 2 $\leq$ x $<$ 4), set y to 3; otherwise (where x $\ge$ 4), set y to 5”.        


Homework: Which curve?
-------------------------
	
1. On page 96 in EMD, Bolker states that the logistic is popular because it is a simple sigmoid function, but then indicates that its "rational analogue," the Holling Type III functional response is also a simple sigmoid function. Does that mean they are interchangeable? Can you get a Holling type III curve to look like a logistic or vice versa? (Say, from 0 to 10.) If so, under what parameters? What about the hyperbolic and the negative exponential?

Send me one figure for each pair showing me how close you were able to get. Make sure you label your axes, etc., and indicate the parameter combinations you used. Closest fit in the class gets a beer.

2. Describe and plot the deterministic function you think would relate your predictor (x-variable) to your response (y-variable). (This likely relates to the data you worked with and plotted last week.) Include a 1-2 sentence caption as you would in a manuscript.



```{r morefunctions, echo=FALSE, eval=FALSE}
Hyperbolic <- function(x, a = 2, b = 3) { a/(b+x) }  
MichMent <- function(x, a = 2, b = 1) { a*x / (b + x) }  
Holling3 <- function(x, a = 2, b = 1) { (a*x^2) / (b^2 + x^2) }  
Holling4 <- function(x, a = 2, b = 3, c = -1) { (a*x^2) / (b + c*x + x^2) }   
Monomolecular <- function(x, a = 2, b = 3) { a*(1 - exp(-b*x) ) }  
Ricker <- function(x, a = 2, b = 3) { a*x * exp(-b*x) }  
Logistic <- function(x, a = 0, b = 1) { exp(a+b*x) / (1 + exp(a+b*x) ) }  
```


```{r guide_Hyperbolic, echo=FALSE, eval=FALSE}

#### NEED TO ADJUST PARAMETES & COLORS

Hyp <- ggplot(data.frame(x=c(0,10)), aes(x)) +   
	stat_function(fun=Hyperbolic, geom="line", args = list(a=1, b = 0.5), aes(colour="a=1, b=0.5")) +   
	stat_function(fun=Hyperbolic, geom="line", args = list(a=1, b = 1), aes(colour="a=1, b=1")) +   
	stat_function(fun=Hyperbolic, geom="line", args = list(a=1, b = 5), aes(colour="a=1, b=5")) +   
	stat_function(fun=Hyperbolic, geom="line", args = list(a=1/2, b = 1), aes(colour="a=0.5, b=1")) +   	stat_function(fun=Hyperbolic, geom="line", args = list(a=5, b = 1), aes(colour="a=2, b=1")) +
	scale_colour_manual("Parameters", values=c("orange", "green","black","darkgreen", "red"), breaks=c("a=1, b=0.5", "a=1, b=1", "a=1, b=5", "a=0.5, b=1", "a=5, b=1")) +   
	labs(title = "Hyperbolic") + theme_bw()
Hyp
```

```{r guide_MichMent, echo=FALSE, eval=FALSE}
MM <- ggplot(data.frame(x=c(0,10)), aes(x)) +   
	stat_function(fun=MichMent, geom="line", args = list(a=1, b = 0.5), aes(colour="a=1, b=0.5")) +   
	stat_function(fun=MichMent, geom="line", args = list(a=1, b = 1), aes(colour="a=1, b=1")) +   
	stat_function(fun=MichMent, geom="line", args = list(a=1, b = 5), aes(colour="a=1, b=5")) +   
	stat_function(fun=MichMent, geom="line", args = list(a=1/2, b = 1), aes(colour="a=0.5, b=1")) +   	stat_function(fun=MichMent, geom="line", args = list(a=5, b = 1), aes(colour="a=2, b=1")) +
	scale_colour_manual("Parameters", values=c("orange", "green","black","darkgreen", "red"), breaks=c("a=1, b=0.5", "a=1, b=1", "a=1, b=5", "a=0.5, b=1", "a=5, b=1")) +   
	labs(title = "Michaelis-Menton") + theme_bw()
MM
```


```{r guide_Holling3, echo=FALSE, eval=FALSE}
H3 <- ggplot(data.frame(x=c(0,10)), aes(x)) +   
	stat_function(fun=Holling3, geom="line", args = list(a=1, b = 0.5), aes(colour="a=1, b=0.5")) +   
	stat_function(fun=Holling3, geom="line", args = list(a=1, b = 1), aes(colour="a=1, b=1")) +   
	stat_function(fun=Holling3, geom="line", args = list(a=1, b = 5), aes(colour="a=1, b=5")) +   
	stat_function(fun=Holling3, geom="line", args = list(a=1/2, b = 1), aes(colour="a=0.5, b=1")) +   	stat_function(fun=Holling3, geom="line", args = list(a=5, b = 1), aes(colour="a=2, b=1")) +
	scale_colour_manual("Parameters", values=c("orange", "green","black","darkgreen", "red"), breaks=c("a=1, b=0.5", "a=1, b=1", "a=1, b=5", "a=0.5, b=1", "a=5, b=1")) +   
	labs(title = "Holling Type III") + theme_bw()
H3
```

```{r guide_Holling4, echo=FALSE, eval=FALSE}

### add in parameter c
H4 <- ggplot(data.frame(x=c(0,10)), aes(x)) +   
	stat_function(fun=Holling4, geom="line", args = list(a=1, b = 0.5), aes(colour="a=1, b=0.5")) +   
	stat_function(fun=Holling4, geom="line", args = list(a=1, b = 1), aes(colour="a=1, b=1")) +   
	stat_function(fun=Holling4, geom="line", args = list(a=1, b = 5), aes(colour="a=1, b=5")) +   
	stat_function(fun=Holling4, geom="line", args = list(a=1/2, b = 1), aes(colour="a=0.5, b=1")) +   	stat_function(fun=Holling4, geom="line", args = list(a=5, b = 1), aes(colour="a=2, b=1")) +
	scale_colour_manual("Parameters", values=c("orange", "green","black","darkgreen", "red"), breaks=c("a=1, b=0.5", "a=1, b=1", "a=1, b=5", "a=0.5, b=1", "a=5, b=1")) +   
	labs(title = "Holling Type IV") + theme_bw()
H4
```

```{r guide_Monomolecular, echo=FALSE, eval=FALSE}
Mono <- ggplot(data.frame(x=c(0,10)), aes(x)) +   
	stat_function(fun=Monomolecular, geom="line", args = list(a=1, b = 0.5), aes(colour="a=1, b=0.5")) +   
	stat_function(fun=Monomolecular, geom="line", args = list(a=1, b = 1), aes(colour="a=1, b=1")) +   
	stat_function(fun=Monomolecular, geom="line", args = list(a=1, b = 5), aes(colour="a=1, b=5")) +   
	stat_function(fun=Monomolecular, geom="line", args = list(a=1/2, b = 1), aes(colour="a=0.5, b=1")) +   	stat_function(fun=Monomolecular, geom="line", args = list(a=5, b = 1), aes(colour="a=2, b=1")) +
	scale_colour_manual("Parameters", values=c("orange", "green","black","darkgreen", "red"), breaks=c("a=1, b=0.5", "a=1, b=1", "a=1, b=5", "a=0.5, b=1", "a=5, b=1")) +   
	labs(title = "Monomolecular") + theme_bw()
Mono
```


```{r guide_Ricker, echo=FALSE, eval=FALSE}
Rick <- ggplot(data.frame(x=c(0,10)), aes(x)) +   
	stat_function(fun=Ricker, geom="line", args = list(a=1, b = 0.5), aes(colour="a=1, b=0.5")) +   
	stat_function(fun=Ricker, geom="line", args = list(a=1, b = 1), aes(colour="a=1, b=1")) +   
	stat_function(fun=Ricker, geom="line", args = list(a=1, b = 5), aes(colour="a=1, b=5")) +   
	stat_function(fun=Ricker, geom="line", args = list(a=1/2, b = 1), aes(colour="a=0.5, b=1")) +   	stat_function(fun=Ricker, geom="line", args = list(a=5, b = 1), aes(colour="a=2, b=1")) +
	scale_colour_manual("Parameters", values=c("orange", "green","black","darkgreen", "red"), breaks=c("a=1, b=0.5", "a=1, b=1", "a=1, b=5", "a=0.5, b=1", "a=5, b=1")) +   
	labs(title = "Ricker") + theme_bw()
Rick
```

```{r guide_Logistic, echo=FALSE, eval=FALSE}
Logist <- ggplot(data.frame(x=c(0,10)), aes(x)) +   
	stat_function(fun=Logistic, geom="line", args = list(a=1, b = 0.5), aes(colour="a=1, b=0.5")) +   
	stat_function(fun=Logistic, geom="line", args = list(a=1, b = 1), aes(colour="a=1, b=1")) +   
	stat_function(fun=Logistic, geom="line", args = list(a=1, b = 5), aes(colour="a=1, b=5")) +   
	stat_function(fun=Logistic, geom="line", args = list(a=1/2, b = 1), aes(colour="a=0.5, b=1")) +   	stat_function(fun=Logistic, geom="line", args = list(a=5, b = 1), aes(colour="a=2, b=1")) +
	scale_colour_manual("Parameters", values=c("orange", "green","black","darkgreen", "red"), breaks=c("a=1, b=0.5", "a=1, b=1", "a=1, b=5", "a=0.5, b=1", "a=5, b=1")) +   
	labs(title = "Logistic") + theme_bw()
Logist
```
